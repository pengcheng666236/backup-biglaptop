# spdk-Storage Performance Developer Kit

## 前言：文件系统

1.分布式文件系统DFS。特点：带网络。分布式文件系统带网络，带网络的不一定是分布式文件系统。

- fastfs，tfs，gfs，glustersfs；ex4/ext3，ntfs；vfs，fuse（用户态文件系统）

- 分布式文件系统结构

  - ![image-20230926121903251](C:\Users\8208191402\Desktop\笔记\图片\image-20230926121903251.png)

  - dfs：用户态下的应用程序，是一个进程。通过多层文件夹的方式，对文件建立多层索引，提高用户态下的访问效率。通过http协议对外界提供服务，相当于FS系统中的应用层，即APP。
  - vfs： OS提供的，浅浅的一层，对于不同的底层文件系统实现，向上层提供统一的接口（read，write，open，close）
  - 底层：内核提供的，不同实现的具体的文件系统，以自己的方式优化文件的存储，索引等等。
  - *fuse：额外的一种存储方式。用户把需要管理的文件夹，挂载到fuse文件系统下，fuse的监控程序会对挂载文件夹的读写操作进行记录。举例来说，当用户需要给每个操作留一条日志，或者需要在文件导出时添加水印，就可以把对应文件夹挂载到fuse下面。用户通过libfuse来操作fuse。

## spdk环境和配置



上面讲的文件系统，都是通过代码实现的。内核文件系统之下，就是磁盘。磁盘和内存之间通过PCI总线通信。

![image-20230926123331440](C:\Users\8208191402\Desktop\笔记\图片\image-20230926123331440.png)

![image-20230926123349044](C:\Users\8208191402\Desktop\笔记\图片\image-20230926123349044.png)

*NVMe在VM11上不支持。*

NVMe是一种固态硬盘的组织方式，一种多个磁头的访问方式。为了解决NVMe提速后（5倍于SCSI）在软件上的瓶颈，出现了spdk。



- VFIO（Virtual Function I/O）和UIO（UserSpace I/O）都是Linux内核的组件，用于在用户空间直接访问设备和进行驱动程序开发。

  1. VFIO（Virtual Function I/O）：VFIO 是一种用于在用户空间直接访问设备的内核子系统。通过 VFIO，用户空间程序可以使用设备的虚拟功能（Virtual Function）进行直接的I/O操作，**绕过了传统驱动程序和操作系统内核**的介入，提供了更低的I/O延迟和更高的性能。

  VFIO 主要使用在虚拟化环境中，例如通过虚拟机管理程序（如QEMU）分配物理设备给虚拟机时，可以使用 **VFIO 来实现设备的直通**（Device Passthrough）。这样，虚拟机可以直接访问物理设备，获得接近本地系统性能的I/O能力。

  > 底层，vfio在内核有模块：vfio
  >
  > OS层，vfio在系统文件中有文件夹：/dev/vfio/vfio
  >
  > 应用层，vfio在用户操作提供了一组库/一层接口：libvfio-user，例如 open（“/dev/vfio/vfio”）

  2. UIO（UserSpace I/O）：UIO 是一种用于设备驱动程序开发的框架，使开发者能够在用户空间实现设备驱动功能。**UIO 允许开发者通过将设备的I/O内存映射到用户空间**，并使用标准的文件I/O接口进行数据传输，从而避免了在内核空间开发驱动程序的复杂性和限制。

  使用 UIO，开发者可以在用户空间使用自己喜欢的编程语言（如C、C++或Python）编写设备驱动程序，实现**对设备的直接控制和数据传输**。这对于一些特定的场景和应用程序，如快速原型开发、特定硬件的驱动开发或用户空间网络协议栈等，非常有用。

  总结而言，VFIO 用于在虚拟化环境中实现设备的**直通**，UIO 则是一种在用户空间开发设备驱动程序的框架，使开发者能够绕过内核直接访问和控制设备。

### 挂载新磁盘

![image-20230926131905187](C:\Users\8208191402\Desktop\笔记\图片\image-20230926131905187.png)

## spdk操作

```xml
创建的项目public在</root/FileSystem/spdk/examples>下
根据makefile文件，编译后运行文件在</root/FileSystem/spdk/build/examples>下
```

### 0.配置大页面

```shell
# 查看大页面虚拟内存
cat /proc/meminfo | grep Huge
# 设置内存大小，把数值写入文件
echo '1024' > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages
# 大页挂载
mkdir /mnt/huge
mount -t hugetlbfs nodev /mnt/huge
```

### 1.运行hello_bdev

​	这里的bdev是block_device，但不是OS的块设备，而是单指一个内存块，因为对他的操作较多，封装起来当做一个设备来看。配置的json文件如下：

```json
{
  "subsystems": [
    {
      "subsystem": "bdev",
      "config": [
        {
          "method": "bdev_malloc_create",
          "params": {
            "name": "Malloc0",
            "num_blocks": 32768,
            "block_size": 512
          }
        }
      ]
    }
  ]
}
```

在spdk文件夹下，shell执行：

```shell
# 他给的，路唇不对马嘴
# ./build/examples/hello_bdev --json ./build/examples/hello_bdev.json -b Nvme0n1
# 修改，第一个参数值执行程序，位置之前提过了，
# 第二个参数是对应的配置文件，路径也是已知的，
# 第三个参数是bdev的名字，json文件中写了
./build/examples/hello_bdev --json ./examples/bdev/hello_world/bdev.json -b Malloc0
```

#### 执行分析

spdk启动后，所有io使用uio来提高效率。执行时的json文件描述了NVMe文件的信息。

```shell
[1] app.c: 786:spdk_app_start: *NOTICE*: Total cores available: 1
[2] reactor.c: 937:reactor_run: *NOTICE*: Reactor started on core 0
[3] hello_bdev.c: 222:hello_start: *NOTICE*: Successfully started the application
[4] hello_bdev.c: 231:hello_start: *NOTICE*: Opening the bdev Malloc0
[5] hello_bdev.c: 244:hello_start: *NOTICE*: Opening io channel
[6] hello_bdev.c: 138:hello_write: *NOTICE*: Writing to the bdev
[7] hello_bdev.c: 117:write_complete: *NOTICE*: bdev io write completed successfully
[8] hello_bdev.c:  84:hello_read: *NOTICE*: Reading io
[9] hello_bdev.c:  65:read_complete: *NOTICE*: Read string from bdev : Hello World!
[10] hello_bdev.c:  74:read_complete: *NOTICE*: Stopping app
```

- 从第6第7行可以看出，write completed操作说明了是一个异步写操作。详细信息见：hello_bdev.c文件中，用户函数hello_write函数中对于异步写的实现：首先调用库函数spdk_bdev_write，传入自定义的回调函数write_complete，用于执行异步任务。
- Linux下对于异步写操作的实现：aio和io_uring。不断跳转查找，得到实现代码：

```c
bdev_io->internal.ch = channel;
bdev_io->internal.desc = desc;
bdev_io->type = SPDK_BDEV_IO_TYPE_WRITE;
bdev_io->u.bdev.iovs = &bdev_io->iov;
	bdev_io->u.bdev.iovs[0].iov_base = buf;
	bdev_io->u.bdev.iovs[0].iov_len = num_blocks * bdev->blocklen;
//这两行就说明了使用的是aio，buf缓存
bdev_io->u.bdev.iovcnt = 1;
bdev_io->u.bdev.md_buf = md_buf;
bdev_io->u.bdev.num_blocks = num_blocks;
bdev_io->u.bdev.offset_blocks = offset_blocks;
bdev_io->u.bdev.memory_domain = NULL;
bdev_io->u.bdev.memory_domain_ctx = NULL;
bdev_io->u.bdev.accel_sequence = NULL;
```

从第8第9行可以看出，read_complete操作说明了是一个异步读操作。

### 2.运行vhost

在spdk文件夹下，shell执行：

```shell
./build/bin/vhost -c ./examples/bdev/hello_world/bdev.json
```

启动服务端

在spdk文件夹下，shell执行：

```shell
./scripts/spdkcli.py
```

启动客户端



#### 执行分析

> 虚拟主机（Virtual Host）是一种**在一个物理服务器上承载多个域名或网站**的技术。通过虚拟主机，你可以在同一台服务器上运行多个网站，**每个网站有自己独立的域名、目录结构和配置**。
>
> 虚拟主机基于客户端的请求，将其**分发**到正确的网站目录，并根据相应的配置提供正确的内容。这使得多个网站可以独立运行而不会相互干扰，提供了更高的灵活性和资源利用率。
>
> *看上去像是一个消息集散中心*

spdk提供了对NVMe数据进行存储，以及对vhost数据组织进行规划的方案。

1.服务端

启动一个虚拟主机进程，分配给主机json文件中描述的空间/块设备，以及执行的方法。

```json
{
  "subsystems": [
    {
      "subsystem": "bdev",
      "config": [
        {
          "method": "bdev_malloc_create",
          "params": {
            "name": "Malloc0",
            "num_blocks": 32768,
            "block_size": 512
          }
        }
      ]
    }
  ]
}
```

![image-20230926145240825](C:\Users\8208191402\Desktop\笔记\图片\image-20230926145240825.png)

![image-20230926145421098](C:\Users\8208191402\Desktop\笔记\图片\image-20230926145421098.png)

当系统添加多个固态硬盘时，可以配置多个vhost，对外提供服务。

分布式文件系统对文件的管理，在于对文件建立索引，便于查找等等，对文件的存储和组织方式是不做操作的。

spdk把对磁盘的块操作放到了用户空间

### 3.用户空间下的文件操作

- 1.读取：spdkcli客户端，也就是把对文件的读取移到了用户空间，而不再是通过系统调用的方式实现读取。这里的Malloc0就是之前json文件里使用的名称。

![image-20230926151414183](C:\Users\8208191402\Desktop\笔记\图片\image-20230926151414183.png)

- 2.修改：要实现对文件的修改，就要通过rpc.py文件。

  直接执行，或者加--help，都可以看到这么操作这个rpc文件。

  执行以下操作，添加一个块设备：

```shell
./scripts/rpc.py bdev_malloc_create 16 512 -b LXCBlock
```



再次查看时，已经多了一块

![image-20230926151853654](C:\Users\8208191402\Desktop\笔记\图片\image-20230926151853654.png)

这里就可以看出，对内存块的读取和创建，都是使用python文件执行。用户可以自定义磁盘的组织结构，自由分配空间，通过使用spdk指令，而不再是通过管态指令的规则或返回的提示进行操作。

- 3.创建新的vhost

  在shell中执行：

  ```shell
  ./scripts/rpc.py vhost_create_scsi_controller --cpumask 0x1 vhost.0
  ```

  会在服务端，也就是最先启动的vhost中看到：

  ![image-20230926152855780](C:\Users\8208191402\Desktop\笔记\图片\image-20230926152855780.png)

​     我们使用网络工具和spdk自身工具分别查找是否真的存在这样一个网络上的主机：

![](C:\Users\8208191402\Desktop\笔记\图片\image-20230926153134134.png)

创建了一个主机，但还没有分配位置，也就是没分配磁盘空间。

```shell
netstat -anop | grep vhost
```

![image-20230926153253132](C:\Users\8208191402\Desktop\笔记\图片\image-20230926153253132.png)

已经可以在网络上找到这个vhost.0了。

下一步，就是给他分配位置。

```shell
./scripts/rpc.py vhost_scsi_controller_add_target vhost.0 0 LXCBlock
```

![image-20230926153610578](C:\Users\8208191402\Desktop\笔记\图片\image-20230926153610578.png)

#### 运行分析

我们通过控制台的shell，控制python脚本，执行rpc调用，修改远端的NVMe。

所执行代码：

```c
static void
rpc_vhost_scsi_controller_add_target(struct spdk_jsonrpc_request *request,
				     const struct spdk_json_val *params)
{
	struct rpc_vhost_scsi_ctrlr_add_target req = {0};
	struct spdk_json_write_ctx *w;
	struct spdk_vhost_dev *vdev;
	int rc;

	if (spdk_json_decode_object(params, rpc_vhost_scsi_ctrlr_add_target,
				    SPDK_COUNTOF(rpc_vhost_scsi_ctrlr_add_target),
				    &req)) {
		SPDK_DEBUGLOG(vhost_rpc, "spdk_json_decode_object failed\n");
		rc = -EINVAL;
		goto invalid;
	}

	spdk_vhost_lock();
	vdev = spdk_vhost_dev_find(req.ctrlr);
	if (vdev == NULL) {
		spdk_vhost_unlock();
		rc = -ENODEV;
		goto invalid;
	}

	rc = spdk_vhost_scsi_dev_add_tgt(vdev, req.scsi_target_num, req.bdev_name);
	spdk_vhost_unlock();
	if (rc < 0) {
		goto invalid;
	}

	free_rpc_vhost_scsi_ctrlr_add_target(&req);

	w = spdk_jsonrpc_begin_result(request);
	spdk_json_write_int32(w, rc);
	spdk_jsonrpc_end_result(request, w);
	return;

invalid:
	free_rpc_vhost_scsi_ctrlr_add_target(&req);
	spdk_jsonrpc_send_error_response(request, SPDK_JSONRPC_ERROR_INVALID_PARAMS,
					 spdk_strerror(-rc));
}
```

这个函数，本质就是一个rpc调用，包含一个rpc函数spdk_jsonrpc_request，和参数spdk_json_val，即一个json协议的rpc调用。

request的结构，包含requestId，buffer，读写指针，函数用得到的值（*values），以及接受返回数据的response。

```c
struct spdk_jsonrpc_request {
	struct spdk_jsonrpc_server_conn *conn;

	/* Copy of request id value */
	const struct spdk_json_val *id;

	/* Total space allocated for send_buf */
	size_t send_buf_size;

	/* Number of bytes used in send_buf (<= send_buf_size) */
	size_t send_len;

	size_t send_offset;

	uint8_t *recv_buffer;
	struct spdk_json_val *values;
	size_t values_cnt;

	uint8_t *send_buf;

	struct spdk_json_write_ctx *response;

	STAILQ_ENTRY(spdk_jsonrpc_request) link;
};
```

通信结构及如下图所示，spdk client通过rpc远程调用，控制NVMe的数据，并获取返回值，把NVMe的状态显示给用户。

![image-20230926154650577](C:\Users\8208191402\Desktop\笔记\图片\image-20230926154650577.png)