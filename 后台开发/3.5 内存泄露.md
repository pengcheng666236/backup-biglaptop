# 内存泄漏

内存泄漏的核心：

- 什么场景下内存会泄露
- 在哪个地方会泄露

## 工具判断方式

### 1.htop/top+肉眼观察

#### htop

![image-20220402185714665](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220402185714665.png)

![image-20220402185905910](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220402185905910.png)

>(1)CPU状态区域
>(2)整体状态区域
>(3)内存状态区域
>(4)进程状态区域
>(5)管理控制区域

#### top

![image-20220402190227630](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220402190227630.png)

### 2.mtrace

使用方式：对原文件加上-g

```shell
gcc -g test.c
export MALLOC_TRACE=a.log 
./a.out 
unset MALLOC_TRACE #记得执行完后unset变量,否则可能运行其他命令可能覆盖log 
mtrace a.out a.log 
```

#### 测试用例

```c
#include <stdio.h>
 
int main()
{
        setenv("MALLOC_TRACE", "lxc.log", "1");
        mtrace();
 
        int *p = (int *)malloc(2 * sizeof(int));
 
        return 0;
}
```

#### 运行结果

![image-20220402191821962](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220402191821962.png)

![image-20220402191912056](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220402191912056.png)

## 函数位置判断方式

- 即malloc没有free，new没有delete的地方

> 一般只适用于离线测试，在线测试不考虑

有两种可能的场景：

- 在可能内存泄露的函数中，额外调用自己的方法进行日志记录。
- 对系统的malloc和free函数进行hook，使得文件调用时能够返回所需要的信息。

### 1.文件调用自己的malloc和free

```c
//每次你怀疑有内存泄漏，就if 1打开
#if 1
void* _malloc(size_t size,const char* file,int line){
    void *p = malloc(size);//正常分配，p指向分配地址

    // printf("malloc[+]:%p --->%s:%ld",p,file,line);
    char buff[128] = {0};
    sprintf(buff,"./mem/%p.mem",p); //设计文件名称格式，放入buff中
    //int sprintf(char* buf, const char* format, ...);
	//它接受一个格式化字符串 format 和一个可变数量的参数，并按照 format 中指定的格式将格式化的数据写入到字符数组 buf 中。最后返回写入到 buf 中的字符数。
    
    FILE* fp = fopen(buff,"w");//打开文件

    fprintf(fp,"[%s:%d]--->addr:%p,size:%ld",file,line,p,size);//把四个参数写入文件
    //%s 用于格式化字符串，%d 用于格式化整数，%p 用于格式化指针，%ld 用于格式化长整数。
    fflush(fp);	
    fclose(fp);
    return p;
}

void* _free(void* p,const char* file,int line){
    char buff[128] = {0};
    sprintf(buff,"./mem/%p.mem",p);//故技重施，把p指向的文件地址format后，给buff
    //unlink应该就是减少一个文件指针，
    //如果 unlink() 执行成功，即返回 0，说明这个文件本身就已经没有引用且被free过了。
    //如果返回值小于 0，表示删除失败，可能是由于权限问题或文件不存在等原因。
    if(unlink(buff) < 0){
        //执行unlink()函数，删除()指定的文件
        
        //如果不是1说明此文件还有其他链接对象，因此只对此文件的连接数进行减1操作
        //若连接数为1，并且在此时没有任何进程打开该文件，此内容才会真正地被删除掉
        //这两种都算是成功
        //返回值：成功返回0，失败返回 -1
        printf("double free. Pointer: %p\n",p);
        return NULL;//实际上 unlink() 函数的返回值并不会影响到函数的返回值，因此需要根据具体需求调整代码逻辑。
    }
    free(p);
    
}


#define malloc(size) _malloc(size,__FILE__,__LINE__);
#define free(size) _free(size,__FILE__,__LINE__);
//宏定义
//__FILE__:调用文件/源文件的文件名；__LINE__:当前源文件中，调用行行号

//注意，如果你的宏定义在你自己的malloc和free函数声明之前，那就不能再你自己的代码里调用系统的malloc函数了

//否则，你每次调用在自己的mallo中调用系统的malloc，就会递归的调用被你改定义的新函数，形成死循环
//所以	声明在实现后面		，因为你实际执行功能的仍然是：改声明之前的同名系统函数
#endif


void func(void){
    void *p1 = malloc(10);
    void *p2 = malloc(20);//不free就删不掉文件
    free(p1);

    void *p3 = malloc(30);
    free(p3);
    return;
}
int main(){
    func();
    return 0;
}
//cd experment/Backend/memory_leak/singleMode
//gcc -o singleFile singleFile.c
// ./singleFile
```

#### 运行结果

![image-20220402192724666](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220402192724666.png)

![image-20220402192733804](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220402192733804.png)

![image-20220402192742412](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220402192742412.png)

> 运行一次，出一个这样的文件，对应程序里的未释放内存：p2指向的区域

#### 限制

你用了宏定义：宏定义这只适用于单个文件。而实际代码往往会在加载时调用第三方so库，在其他文件中的malloc仍然是系统函数，无法记录其他文件中的内存泄漏。因此在多文件环境下不可以用。

### 2.对malloc和free函数做一个hook（dlsym）

hook固定格式：定义一个与原函数同一**回调类型**的函数，做hook用

```c
typedef void*(*malloc_t)(size_t size);//定义的hook函数类型，通过函数指针调用
malloc_t malloc_f = NULL;//一个该hook函数的指针变量

typedef void(*free_t)(void* p);
free_t free_f = NULL;
```

#### 关于dlysm

```c
void *dlsym(void *handle, const char *symbol);
```

它的作用是在 `handle` 所指定的共享库中，查找名为 `symbol` 的符号，并返回该符号对应的地址。

- `handle` 是通过 `dlopen` 函数打开共享库后返回的句柄（或句柄的指针）。
- `symbol` 是一个字符串，表示要查找的符号的名称。

`dlsym` 函数可以用于**在运行时动态获取共享库中的函数地址或全局变量地址**。通过获取符号的地址，我们可以**直接调用该函数或访问全局变量**。

下面是一个示例代码，演示了如何使用 `dlopen`、`dlsym` 和 `dlclose` 函数动态加载共享库，并获取其中一个函数的地址并调用：

```c
#include <stdio.h>
#include <dlfcn.h>

int main() {
    void *handle = dlopen("mylibrary.so", RTLD_LAZY);
    if (handle == NULL) {
        printf("Failed to open library: %s\n", dlerror());
        return 1;
    }

    // 获取符号 "my_function"
    void (*my_function)() = dlsym(handle, "my_function");
    if (my_function == NULL) {
        printf("Failed to get symbol: %s\n", dlerror());
        dlclose(handle);
        return 1;
    }

    // 调用函数
    my_function();

    dlclose(handle);
    return 0;
}
```

在上面的示例中，首先我们使用 `dlopen` 函数打开名为 "mylibrary.so" 的共享库，并获得一个句柄，然后使用 `dlsym` 函数获取共享库中名为 "my_function" 的符号的地址，将其赋给函数指针 `my_function`，然后我们就可以通过该函数指针调用函数了。最后，使用 `dlclose` 函数关闭共享库。

需要注意的是，使用 `dlsym` 函数需要包含 `dlfcn.h` 头文件，并在链接时需要将 `-ldl` 选项传递给编译器，以链接 `libdl` 库。

这样，我们可以在运行时动态加载共享库，并根据需要获取其中的符号地址，并进行调用或访问。这提供了一种灵活的方式来扩展程序的功能。

#### 执行流程

程序启动时，对空的hook函数指针初始化：

```c
static void init_hook(){
    if(malloc_f == NULL){
        malloc_f = dlsym(RTLD_NEXT,"malloc");
    }
    if(free_f == NULL){
        malloc_f = dlsym(RTLD_NEXT,"malloc");
    }
}
```

- 这段代码片段展示了一种在 C 语言中使用 `dlsym` 函数的常见技巧，用于替换标准库函数的实现。

- 在这段代码中，通过检查 `malloc_f` 是否为 `NULL`，来确定是否需要获取 `malloc` 函数的地址。

- 如果 `malloc_f` 为 `NULL`，即表示尚未获取 `malloc` 函数的地址，那么使用 `dlsym` 函数以 `RTLD_NEXT` 参数作为 `handle` 来获取下一个与当前共享库关联的 `malloc` 函数的地址，并将其赋值给 `malloc_f`。

-  `RTLD_NEXT` 是用来指定**在共享库中搜索下一个匹配符号**的特殊宏。这样，可以保证获取到的 `malloc` 函数的**地址是在标准库实现之后出现的下一个**。

- 这样的技巧可以用来替代标准库函数的实现，以方便自定义或拦截对标准库函数的调用。通过获取函数的地址，并使用函数指针进行调用，可以在保留原有函数行为的前提下，添加自定义的逻辑或进行其他操作。

- 需要注意的是，这段代码的前提是，在链接时需要使用 `-ldl` 选项来链接 `libdl`，以便在程序中使用动态链接相关的函数和宏。

init_hook()操作放在main函数入口的地方（第一行）；不用检查内存泄漏的时候把第一行注释掉就行

```c
#define DEBUG_MEMLEAK init_hook();
int main(){
    DEBUG_MEMLEAK;
    func();
    return 0;
}
```

具体两个函数的覆写内容和前面完全一样，但是**函数名和系统函数名一样了，里面调用的不再是系统函数**，而是你定义的函数指针。

*为了防止递归调用，还需要一个全局变量，确保只有第一次进入的时候执行你覆写的函数，其他的不会递归执行，即**保证你的函数不可重入***

完整代码

```c
#define _GNU_SOURCE         
/* 开启GNU特殊性质的，也可以理解为打开dlgcn.h里功能的 */
/* 你在设计模式里也用过了，ifdef.....里面的可以选择执行的...endif */
/* 这必须是您的第一个预处理器指令，在你要启动文件前面声明，相当于文件开关*/
#include<dlfcn.h> 
#include<stdio.h>
#include<stdlib.h>

#include<unistd.h>

        
//hook:定义一个和malloc同一回调类型的函数
typedef void*(*malloc_t)(size_t size);//函数指针
malloc_t malloc_f = NULL;

typedef void(*free_t)(void* p);
free_t free_f = NULL;


int enable_hook_malloc = 1;
int enable_hook_free = 1;
//防止在你覆写的malloc函数里，递归调用新的malloc函数（例如这里的fopen会调用系统的free），导致文件引用计数不一致
//因为有的调用malloc可能会自己free，这样你再free就double free，导致unlink返回错误值
void* malloc(size_t size){
    if(enable_hook_malloc){
    	enable_hook_malloc = 0;
    void *p = malloc_f(size);

    void* caller = __builtin_return_address(0);//返回上一级调用点，0表示上一层,1表示上上层，以此类推，别打错了！
    //__FILE__和__LINE__只能在宏定义中，函数调用可能会跨文件，不能再使用局限于本文件的宏，所要用__builtin_return_address找到malloc的调用处

    char buff[128] = {0};
    sprintf(buff,"./mem/%p.mem",p);
    
    FILE* fp = fopen(buff,"w");

    fprintf(fp,"[+%p]--->addr:%p,size:%ld",caller,p,size);//file和line被替换成caller
    fflush(fp);	
    fclose(fp);
        enable_hook_malloc=1;
    }else{
        return malloc_f(size);
    }
    return p;
}

void free(void* p){
    if(enable_hook_free){
        enable_hook_free=0;
    char buff[128] = {0};
    sprintf(buff,"./mem/%p.mem",p);
    if(unlink(buff) < 0){
        printf("double free.\n",p);
        enable_hook_free=1;
        return;
    }
    free_f(p);
        enable_hook_free=1;
    }else{
        free_f(p);
    }
    return;
}

static void init_hook(){
    if(malloc_f == NULL){
        malloc_f = dlsym(RTLD_NEXT,"malloc");
    }
    if(free_f == NULL){
        malloc_f = dlsym(RTLD_NEXT,"malloc");
    }
}

#define DEBUG_MEMLEAK init_hook();


void func(void){
    void *p1 = malloc(10);
    void *p2 = malloc(20);
    free(p1);

    void *p3 = malloc(30);
    free(p3);
    return;
}

int main(){
    DEBUG_MEMLEAK;
    func();
    return 0;
}
//cd experment/Backend/memory_leak/multiMode
//gcc -o mem_hook mem_hook.c     这样就会undefied reference to dlsym
//gcc -o mem_hook mem_hook.c -ldl
// ./mem_hook

//dlsym 报错，就查看怎么用这个：man dlsym
```

# 部分重同步（partial resynchronization）

- 部分重新同步是一种仅同步两个系统或设备之间的部分数据的过程。这可以帮助减少同步大量数据所需的时间和资源，并且还可以帮助最小化同步对系统性能的影响。
- 部分重新同步可以在各种情况下使用，例如数据库复制，文件同步和数据备份。在数据库复制中，有时候只需要将**最新的数据**同步到备份数据库中，而不需要将整个数据库都进行同步。在文件同步中，只有**新增或修改的文件**需要进行同步，而原有的文件则不需要进行同步。在数据备份中，只有**最新的数据**需要备份，而历史数据则不需要备份。这可以帮助减少在两个系统之间传输的数据量，并且还可以帮助最小化同步对系统性能的影响。
- 可以使用各种技术实现部分重新同步，例如增量同步，差异同步和选择性同步。其中，增量同步是一种常用的技术，它只同步自上次同步以来发生的更改。例如，在数据库复制中，增量同步只同步最新的数据记录，而不同步整个数据库。在文件同步中，增量同步只同步新增或修改的文件，而不同步原有的文件。增量同步可以帮助减少数据传输的量，提高同步的效率。除了增量同步之外，还有其他的部分重新同步技术，例如差异同步和选择性同步。差异同步只同步两组数据之间的差异，而不同步整个数据集。选择性同步只同步数据集中符合特定标准的数据，例如日期或文件类型等。这些技术可以根据具体的应用场景进行选择和应用。

# AOF 持续IO问题


AOF（Append Only File）持续IO的问题是指Redis在写入AOF文件时，由于写入速度较慢，会导致Redis的性能下降。解决方法如下：

>1. 开启AOF重写：AOF重写会将AOF文件中的**冗余命令去掉**，**减少AOF文件的大小**，从而提高写入速度。
> 2. **开启AOF缓存**：AOF缓存可以将AOF文件的**写入，缓存到内存**中，当缓存满时再写入AOF文件，可以减少AOF文件的写入次数，提高写入速度。
>3. 调整AOF刷盘策略：可以通过设置AOF文件刷盘的频率和方式来优化AOF的性能。例如，可以将AOF文件刷盘的频率调整为每秒一次，或者使用异步刷盘方式。
> 4. 使用SSD硬盘：SSD硬盘的读写速度比传统的机械硬盘更快，可以提高Redis的写入速度。
> 5. 升级Redis版本：新版本的Redis可能会对AOF持续IO问题进行优化和改进，可以尝试升级Redis版本来解决问题。
