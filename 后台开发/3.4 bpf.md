# bpf

# 内存泄漏工具bpftrace

## 使用方法

查看使用方法

```shell
bpftrace -l "t:syscalls:*read"
bpftrace -e 就是具体执行后面的挂载操作

```

会显示有哪些接口，也是挂载点函数。当程序执行到挂载点时，就会执行对应的挂载函数。

挂载点：

```c
prob / pid==,comm / {
    action
}
```

prob：挂载地址；`pid==`和comm：触发条件；action：触发后执行的操作

```shell
bpftrace -e 'BEGIN { printf("hello world\n");}'
```

![image-20230930165344906](C:\Users\8208191402\Desktop\笔记\图片\image-20230930165344906.png)

>  WSL2 提供的内核不包含必要的内核头文件（kheaders），要进行内核级别调试要去真正的linux。

对于内存泄漏代码

- 挂载位置：系统的malloc函数和free函数
- 执行操作：进行++和--，根据计数是否为0判断是否泄漏，或者直接打印，肉眼判断。
- 判断条件，系统中有无数个malloc和free，因此需要确保是在我们的测试代码中，或者实际可能泄露的代码进程中执行，即条件为：进程`pid==`

```c
void func(void){
    void *p1 = malloc(10);
    void *p2 = malloc(20);
    free(p1);

    void *p3 = malloc(30);
    free(p3);
    return;
}
//malloc不是系统调用，而是libc提供的接口，libc是用户态的，不是内核态的
```

## 简单实例1

>  libc库提供的malloc/free方法

1.寻找挂载点，在c文件所在文件夹下，找到libc库的位置

```shell
ls /lib # 找到可能的库
ls /lib/x86_64-linux-gnu/libc.* # 查看库
```

![image-20230930171439999](C:\Users\8208191402\Desktop\笔记\图片\image-20230930171439999.png)

出现三个libc库，寻找这三个文件哪一个指向libc库文件。

```shell
ls /lib/x86_64-linux-gnu/libc.* -l
```

![image-20230930171620866](C:\Users\8208191402\Desktop\笔记\图片\image-20230930171620866.png)

可见：`/lib/x86_64-linux-gnu/libc.so.6`是对不同版本libc库进行抽象的，使用软连接可以确保无论libc版本如何更新，都可以使用相同的接口来访问其中的内容和函数，因此这个就是执行libc库的接口，也就是我们的挂载点。

2.新建mamory.bt，写入两个挂载点。

- 挂载点格式：空间（内核空间kprobe还是用户空间uprobe）：挂载点函数所属的库名称：要挂载的函数
- 条件：当我的测试进程运行时，进行测试
- 内容：打印提示

```c
uprobe:/lib/x86_64-linux-gnu/libc.so.6:malloc / comm == "memory" / {
    printf("memory --> malloc\n");
}

uprobe:/lib/x86_64-linux-gnu/libc.so.6:free / comm == "memory" / {
    printf("memory --> free\n");
}
```

3.执行，首先启动bpftrace，对可能泄露的程序进行监控

```shell
bpftrace memory.bt
```

然后执行程序，检验输出

![image-20230930180949811](C:\Users\8208191402\Desktop\笔记\图片\image-20230930180949811.png)

![image-20230930180958566](C:\Users\8208191402\Desktop\笔记\图片\image-20230930180958566.png)

### 方法1总结

bpf可以让你原来的线上代码不需要修改，而是用.bt程序来自定义你的监控过程。

换一种形式，将原来的bt文件命名为memory1，添加变量进行计数。

```c
BEGIN / comm == "memory" / {
    @count[comm] = 0;
}

uprobe:/lib/x86_64-linux-gnu/libc.so.6:malloc / comm == "memory" /{
    @count[comm]++;
    printf("memory --> malloc\n");
}

uprobe:/lib/x86_64-linux-gnu/libc.so.6:free / comm == "memory"/{
    @count[comm]--;
    printf("memory --> free\n");
}
```

![image-20230930181642020](C:\Users\8208191402\Desktop\笔记\图片\image-20230930181642020.png)

## 简单实例2

> libc库提供的pthread_create()方法

*关于在打印时需要+\n：因为printf是写入libc库的缓冲区，遇到\n才会刷缓冲区。*

pthread.bt

```c
uprobe:/lib/x86_64-linux-gnu/libpthread.so.0:pthread_create / comm=="pthread" /
{
    printf("bpf:pthread has been created.\n");
    
}
```

pthread.c

```c
#include <pthread.h>
void* thread_callback(void* args){

}
#define threadCount  10
int main(int argc, char const *argv[])
{
    pthread_t threads[threadCount];
    for(int i=0;i<threadCount;i++){
        pthread_create(&threads[i],NULL,thread_callback,NULL);
    }
    return 0;
}

```

shell

```shell
~/BackEnd_Devenlopment/memory/memory_leak/bpf# bpftrace pthread.bt

~/BackEnd_Devenlopment/memory/memory_leak/bpf# gcc -o pthread pthread.c -pthread
~/BackEnd_Devenlopment/memory/memory_leak/bpf# ./pthread
```

![image-20231001162423744](C:\Users\8208191402\Desktop\笔记\图片\image-20231001162423744.png)



## 总结

可挂载的位置：

- kprobe：系统调用（系统库）tracepoint所提供的位置，
- kprobe：内核模块提供出来的函数
- uprobe：可执行程序，nginx
- uprobe：动态第三方库（不只是系统库）：libc.so，pthread.so
- 可执行程序和动态库都属于linux系统的elf文件，即可执行文件。当执行./pthread时，相当于把程序内容，数据段，堆栈，BS字段都加载到内存中，构建一个进程。bpf就是在程序执行的一开始进行挂载的。

无论代码使用说明语言实现，只要使用了相同的库，甚至相同的系统调用，都可以用bpf进行挂载，.bt文件内容不需要改变。

## 业务

> 在nginx服务器启动后，获取新建立的连接（挂载在accept），并获取连接上传输的数据大小（挂载在receive）

分析

- 没有那个系统调用/库是把accept和receive函数封装到一起的，一般都是用action模型，对这两个行为进行异步操作
- 在建立TCP连接时，为了提高数据利用率，第三次握手的数据包中，除了ack=1来表示第三次握手外，也会把要传输的数据放在这个数据包中，放到接收端的，内核中用于接收数据包的skbuf中。 

首先通过shell查询bpftrace提供哪些和tcp transmission相关的接口

```shell
bpftrace -l '*transmit_skb'
```

找到kprobe：__tcp_transmit_skb，需要查看内核源码，进行代码分析

![image-20231001170213193](C:\Users\8208191402\Desktop\笔记\图片\image-20231001170213193.png)

![image-20231001170337772](C:\Users\8208191402\Desktop\笔记\图片\image-20231001170337772.png)

与连接相关的是sock和sk_buff，相关信息应该在sock中，数据在sk_buff中

![image-20231001170447792](C:\Users\8208191402\Desktop\笔记\图片\image-20231001170447792.png)

​	查看结构体sock_common

![image-20231001170629312](C:\Users\8208191402\Desktop\笔记\图片\image-20231001170629312.png)

skc_addrpair是（本机ip，远端ip），分别为skc_rcv_saddr和skc_daddr

> `skc_rcv_saddr` 表示套接字的本地接收地址。对于TCP套接字，它用于表示本地接收数据的IP地址。对于UDP套接字，它表示套接字所绑定的本地IP地址。该字段用于指示在网络层传输数据时，数据将被传送到的接口和地址。
>
> `skc_daddr` 表示套接字的远程目标地址。对于TCP套接字，它表示远程连接的IP地址。对于UDP套接字，它表示套接字发送数据的目标IP地址。该字段用于指示在网络层传输数据时，数据将被发送到的接口和地址。
>
> 这两个字段通常用于网络编程中，特别是当您需要识别与套接字相关的地址信息时。但请注意，`skc_rcv_saddr` 和 `skc_daddr` 是内核级别的字段，并且在用户级别的应用程序中使用时可能需要特殊的权限和访问控制。

同理，skc_portpair包含了本机ip（skc_rcv_saddr）和服务端ip（skc_dport）

transmit_skb.bt

```c
#include <net/sock.h>
kprobe:__tcp_transmit_skb / comm=="nginx" /
{
    $sk = (struct sock*)arg0;

    $daddr = ntop($sk->__sk_common.skc_daddr);
 	$laddr = ntop($sk->__sk_common.skc_rcv_saddr);
    printf("tcp transmit_skb,src:%s,dst:%s\n",$laddr,$daddr);
}
```

![image-20231001171340157](C:\Users\8208191402\Desktop\笔记\图片\image-20231001171340157.png)

运行nginx服务器，实用工具建立远端连接，就可以获取连接的信息，包括args0中的src和dst，以及args1的buffer中的内容，以及最后一个参数中的数据包序列号。
