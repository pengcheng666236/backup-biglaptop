# MySql的事务

## MySQL连接过程

> - 客户端发起请求
>- MySQL主线程把客户端fd添加到select线程里，子等待
> - select选择适当时候接受clientfd
>- MySQL分配连接线程去处理客户端请求
> - 子线程任务：循环读取sql语句，执行语句

![image-20220403142340798](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403142340798.png)

## 事务的目的

1.数据库需要数据的完整性（约束；主键，自增，外键，触发器）

2.确保数据库从一个一致性状态转换到另一个一致性状态，确保数据库完整性。

## 事务的特性(ACID)

- 原子性A：一系列操作序列，要么都做（commit），要么都不做（rollback）。

- **一致性C**：一致性检测（完整性约束检测），数据库需要数据的完整性（约束；主键，自增，外键，触发器）

  *一致性是其他三个特性共同来维持的*

- 隔离性I：

> 描述：各个事务之间的影响程度（锁粒度）
>
> 目的：当多个事务访问同一资源，限制各事务对该资源的访问行为。
>
> 策略：
>
> - 写加锁，读不加锁。
> - 采用版本机制（MVCC，每行数据有一个版本）
>
> 作用：在**牺牲一致性的前提下，提高MySQL性能**。

> 隔离级别：
>
> - 最高：串行操作，读写都加锁（serializable）。
>   - **不会影响一致性，下面的都会一定程度影响一致性**
>
> - 其次：repeatable read，可重复读，读采用MVCC，写加锁
>
>   - **幻读问题**
>   - MVCC采用读取事务开始之前的版本。（在事务过程中，其他事务对记录的修改不会被本事务读取到）
>
>   - 快照读：读取事务开始之前的版本，而且事务内部不会修改记录。
>   - 当前读，随着事务内部sql语句的执行，读取被当前事务修改的记录数据。
>
> - 再次：read committed，读已提交，读采用MVCC，写加锁。
>
>   - **不可重复读，幻读问题**
>   - MVCC采用读取事务最新的版本。（事务内sql1和sql2之间，被事务外sql3修改了记录，sql2读取sql3修改后的记录）
>
> - 最低：read uncommitted，读未提交，读不加锁，写加锁，不采用MVCC。
>
>   - **脏读，不可重复读，幻读问题**

## 并发读异常

### 脏读

一个事务读取了另一个事务尚未提交的数据

> 原因：
>
> - 并发事务：脏读问题通常发生在多个事务并发执行的环境中。当**多个事务**同时读取和修改数据库中的数据时，就可能发生脏读。
>   - 数据未提交：脏读问题的核心是一个事务读取了另一个事务尚**未提交**的数据。当一个事务修改了某条数据但还未提交时，其他事务可能读取到这个尚未提交的数据，导致脏读。
>   - 事务操作的顺序：事务执行的顺序也可能导致脏读。如果一个事务在另一个事务提交之前就先进行了读取操作，就可能读取到尚未提交的数据。
> - 事务隔离级别不一致：数据库系统通常提供多种**事务隔离级别**，如读未提交（Read Uncommitted）、读提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。如果事务隔离级别较低，例如读未提交级别，就容易产生脏读问题。
>
> 为了避免脏读问题，数据库系统提供了不同的并发控制机制，例如行级锁、多版本并发控制（MVCC）、锁定表等。
>
> *事务内的每条sql语句，在不使用存储过程的情况下，相当于在网络上走了一个来回*
>
> 主数据库使用可重复读rr（repeatable read），从数据库使用读未提交ru（read uncommited）提高效率。

### 不可重复读（单行数据）

对同一个数据多次读取，结果不一致；换句话说，一次事务内的两次读取操作之间发生了其他事务的数据修改并提交，导致读取的结果不一致。RWR

原因：

- 并发事务的修改：当一个事务正在执行读操作时，另一个并发的事务对同一行数据进行了**修改**并提交，导致第二次读取获取到的数据发生了变化。
- 事务隔离级别：事务隔离级别较低（例如读未提交级别，Read Uncommitted），允许读取未提交的数据。如果一个事务在读取某行数据后，另一个事务对该行数据进行了修改并提交，那么第一个事务再次读取该行数据时，获得的结果就会发生变化。
- 单个事务中的操作顺序：在一个事务内，如果先执行了一次读操作，然后在之后执行了一次或多次的写操作，再次读取同一行数据时就可能出现不一致的结果。
- 一个读操作和一个写操作造成的：一个事务读到另一个事务已经commit的数据。

隔离级别：

- 读未提交（Read Uncommitted）隔离级别：在读未提交的隔离级别下，一个事务可以读取到其他事务尚未提交的数据。这就意味着，如果一个事务在读取某一行数据之后，另一个事务对同一行数据进行了修改并提交，造成第一个事务再次读取该行数据时，获得的结果就会发生不一致，从而出现不可重复读的情况。

- 读已提交（Read Committed）隔离级别：在读已提交的隔离级别下，一个事务只能读取到其他事务已经提交的数据。然而，由于并发事务的存在，一个事务在多次读取同一行数据的过程中，其他事务可能已经修改并提交了该行数据，导致每次读取的结果不一致，进而产生不可重复读。

  可重复读（Repeatable Read）和串行化（Serializable）是可以避免不可重复读问题的两个隔离级别。在这两种隔离级别下，事务会使用锁定机制来确保读取的数据在事务结束之前不会被其他事务修改，从而解决了不可重复读的问题。



#### 执行序列实例

![image-20220403160254175](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403160254175.png)

### 幻读（多行数据）

不可重复读是两次读的数据某些不一样，数量是相同的；幻读是两次读的数据数量不同，增加或缺少了某些行。

幻读出现的主要原因是并发事务对数据进行了插入或删除操作，导致其他事务在相同的查询操作中获取到了不同的结果集。

1. 并发事务插入或删除数据：在一个事务执行期间，另一个并发的事务对相同的数据集合执行了**插入或删除**操作，改变了数据的行数，从而导致了幻读。例如，一个事务在查询某个表的数据时，另一个事务插入了满足查询条件的新行，那么第一个事务再次查询时将返回更新后的结果，产生了幻读。
2. 事务隔离级别：幻读一般在读已提交（Read Committed）隔离级别下会出现。在这个隔离级别下，事务会在每次查询时获取最新提交的数据，因此如果其他事务对数据进行了插入或删除操作，就可能导致幻读的发生。
3. 行级锁定：如果事务在读取数据时对数据集合采用了行级锁定（行锁），而其他事务对其中包含的行进行了插入或删除操作，就会导致产生幻读。因为行级锁定只能锁住存在的行不被修改，确保不出现不可重复读。下一次操作插入新行，就会导致结构和上次不一致。

为了避免幻读问题，可以采取以下措施：

- 将事务的隔离级别设置为可重复读（Repeatable Read）或串行化（Serializable），这样可以使用锁定机制来避免并发事务对数据的修改操作。
- 在需要保证数据一致性的场景下，使用更严格的锁定级别，如行级锁定或表级锁定，以减少幻读的风险。
- 通过合理的事务设计和应用程序逻辑，避免并发的插入和删除操作对查询结果的影响。
- 在一些数据库系统中，提供了乐观并发控制的机制，如使用版本控制或快照隔离来解决幻读问题。

> 为什么行级锁定既是问题，也是方案。因为行级锁定可以锁住查询的行。这些行被锁住，就不能想这些行插入新的列数据，也不能删除这些行，从而可以解决。但是我可以加入新的行，这样还是会出现幻读，所以行级锁定增大了插入行操作的可能性（别的操作无法执行），因此也是幻读的原因。

在标准的事务隔离级别中，可重复读（Repeatable Read）隔离级别会出现幻读问题。

1. 可重复读隔离级别：在可重复读隔离级别下，事务会在第一次读取数据后创建一个快照，并在当前事务执行期间使用该快照来保证每次读取的数据一致性，避免了不可重复读。但是可重复读隔离级别并没有解决幻读的发生。如果第二个并发事务对数据进行了插入或删除操作，就可能导致在第一个事务内查询相同条件的结果集合时，返回的结果数量不一致，产生了幻读。

   串行化隔离级别：串行化是最高的隔离级别，它可以解决幻读的问题。在串行化隔离级别下，事务会被强制串行执行，不会出现并发问题，因此可以避免幻读的发生。但是这种隔离级别的代价是牺牲了并发性能，因为事务必须依次执行，可能导致较长的等待时间。

   其他隔离级别（读未提交和读已提交）通常不会出现幻读，因为它们在读取数据时不会创建快照或锁定数据，而是直接读取最新提交的数据。不过，这些隔离级别可能会导致不可重复读问题。

需要注意的是，虽然可重复读隔离级别和串行化隔离级别可以避免幻读，但它们并不能完全消除并发控制问题。在某些情况下，仍然需要结合使用其他并发控制技术（如锁定和乐观并发控制）来处理更复杂的并发场景。

> 隔离级别：可重复读

> 两次查询得到的结果集合不一致（事务对数据进行delete和insert）
>
> 数量不一致：删除/插入 
>
> 内容不一致：先插入再删除

#### 执行序列实例

![image-20220403160503806](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403160503806.png)

### 总结：

> 不可重复读和幻读都是其他事务对本事务操作数据进行修改导致的。
>
> 1.隔离级别
>
> 读已提交：MVCC，读取最新版本
>
> 可重复读：MVCC，快照读，读取事务之前的版本
>
> 2.出现的范围
>
> 不可重复读：一行记录
>
> 幻读：结果集
>
> 3.原因
>
> 不可重复读：update
>
> 幻读：delete，insert
>
> 4.解决：
>
> 不可重复读：提高隔离级别即可解决。
>
> 幻读：把快照读（MVCC来实现）改成当前读（给读加锁实现）。

```sql
select * from table where ... for update;  加读锁
select * from table where ... lock in share mode;	加写锁
```

手动加锁，就是当前读

```sql
insert into ... values ...  虽然是插入语句，但是要先找到插入的位置，还是包含了读操作
update ... set ... ... where ...
delete from where 
```

快照读转当前读，就是在select语句后面加上lock in share mode;读锁即可

持久性D：落盘，系统重新加载时，可以获取之前的事务提交记录和数据变更。

## 并发死锁

> 前提：并发，采用连接池 或 多个server发起MySQL连接时

![](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403163244393.png)



![image-20220403162641267](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403162641267.png)



![image-20220403162840580](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403162840580.png)

S锁：若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。

这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

X锁：若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。

这保证了其他事务在T释放A上的锁之前不能再读取和修改A。

AI锁：自增锁。

![image-20220403163510670](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403163510670.png)

第二种多出现在RR隔离级别下（引入间隙锁）

## 集群方案

mysql：分库分表，MyCat，介于server和MySQL server之间的代理。

![image-20220403163856173](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403163856173.png)

难以管理

引出NewSQL：分布式关系型数据库。

> 组成：分布式系统（便于横向扩展） + 关系型sql + 分布式事务XA

关系型数据库的两种用途：OLAP（在线业务分析），OLTP（在线业务处理）（用到XA）

