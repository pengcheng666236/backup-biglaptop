# 锁

nginx（高并发服务框架）应用：静态web服务器

```shell
locate nginx.conf
```

## 前言：静态web服务器的两个流程

### 连接处理

#### 综述

![image-20220403213110164](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403213110164.png)

> 1.master进程读取nginx.conf ，把这个配置文件**加载到共享内存中**；同时listen(8888)端口，fork一些worker进程。
>
> 2.每一个fork的worker进程都执行listen(8888)操作。
>
> 3.客户端发起请求，**多个worker进程竞争连接处理业务**。
>
> 解决方式：**把业务数据放在worker共享内存的accept锁**，谁获得锁谁处理。

#### accept锁的组成

对于worker的锁结构体，根据worker不同的参数配置，设置成不同的锁

```c
//nginx使用ngx_int_t封装int，使用ngx_uint_t封装unsigned int
typedef struct {
//实现在多进程下加锁
//如果有原子操作选项
#if (NGX_HAVE_ATOMIC_OPS) 				
    ngx_atomic_t  *lock;				//声明原子锁
//ngx_atomic_t在不同平台上的实现方式可能不同，可以通过编译器提供的原子操作函数实现。
//例如，在Linux平台上，可以使用GCC编译器提供的原子操作函数，如__sync_fetch_and_add()、__sync_fetch_and_sub()等。
//在Windows平台上，可以使用Visual C++编译器提供的Interlocked操作函数，如InterlockedExchangeAdd()、InterlockedExchangeSub()等。

//如果支持信号量，在Linux系统中，POSIX信号量定义在<semaphore.h>头文件中，可以使用sem_init()、sem_wait()、sem_post()等函数来创建和操作信号量。
#if (NGX_HAVE_POSIX_SEM)				
    ngx_atomic_t  *wait; //原子锁
    ngx_uint_t     semaphore;//信号量支持的个数
    sem_t          sem;	 //表示POSIX信号量
#endif
//不支持信号量操作，建立文件锁
#else
    ngx_fd_t       fd;//描述符
    u_char        *name;//文件路径
#endif
//不支持原子锁
    ngx_uint_t     spin;				//自旋锁，忙时等待机制，因为无法确保原子访问，只能等着
} ngx_shmtx_t;
```

#### accept锁的使用（解决哪个worker进程拿到锁）

```c
typedef ngx_atomic_t  ngx_atomic_int_t;

volatile ngx_atomic_int_t  *ngx_accept_mutex_ptr;//指向原子int的指针，用于进行原子操作
ngx_atomic_int_t           ngx_accept_mutex;//可确保原子操作的int，用来表示accept锁得状态，初值0
//锁初始化，用一个原子指针指向原子变量
void ngx_accept_mutex_init(ngx_cycle_t *cycle)
{
    ngx_accept_mutex_ptr = &ngx_accept_mutex;
}

void ngx_accept_mutex_lock(ngx_cycle_t *cycle)
{//看出是自旋锁了
    while (ngx_atomic_cmp_set(ngx_accept_mutex_ptr, 0, ngx_cycle->worker) != 0) {
        //如果原子变量值为0，则通过指针把它设置为当前worker进程的编号，否则等待
        ngx_cpu_pause();
    }
}

void ngx_accept_mutex_unlock(ngx_cycle_t *cycle)
{
    ngx_atomic_cmp_set(ngx_accept_mutex_ptr, ngx_cycle->worker, 0);
    //设回0，表示用完了
}
```

#### 尝试获得/非阻塞

```c
//共享内存锁
//如果获取锁成功，则返回1，否则返回0
if (ngx_shmtx_trylock(&ngx_accept_mutex)) {
//获取锁成功，会将ngx_accept_mutex_held标志位设置为1，表示当前worker进程已经获取到了accept锁
        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                       "accept mutex locked");
    
        if (ngx_accept_mutex_held && ngx_accept_events == 0) {
            //ngx_accept_events的值是否为0，如果是，则说明当前没有新的连接请求需要处理，而我又占有锁，说明我目前正在等待accept事件，可以处理建立连接事件，通知调用者（server线程）。
            return NGX_OK;
        }
		//处理accept事件
        if (ngx_enable_accept_events(cycle) == NGX_ERROR) {
            ngx_shmtx_unlock(&ngx_accept_mutex);
            return NGX_ERROR;
        }

        ngx_accept_events = 0;
        ngx_accept_mutex_held = 1;
    //如果已经获取到了，则不需要再次获取accept锁，可以直接处理连接请求。
    //如果没有获取到accept锁，则需要先获取accept锁再处理连接请求。
    //这样做的目的是为了避免多次获取accept锁而浪费CPU资源，提高程序的性能。因为accept数量可能不止一个，下次如果不这么设置，就要在使用一次trylock甚至lock，降低性能
    //也就是第一个if的判断

        return NGX_OK;
    }
```

#### trylock的函数实现

```c
ngx_shmtx_trylock(ngx_shmtx_t *mtx)
{	//cas锁：ngx_atomic_cmp_set，compare and set
    return (*mtx->lock == 0 && ngx_atomic_cmp_set(mtx->lock, 0, ngx_pid));
    
    //ngx_atomic_cmp_set(mtx->lock, 0, ngx_pid))
    //如果mtx->lock的值等于0，把锁的值设置成ngx_pid，返回设置的值,相当于拿到了锁，声明是自己占用
    //否则返回0，说明没拿到锁，但也不阻塞，立刻返回，所以叫trylock
}
```

#### 硬要获得锁的实现

代码位置

![image-20220403204453069](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403204453069.png)

###### 信号量回顾

三个函数：sem_init()

下面是man sem_init()的结果，主要是声明sem变量要是一个所有线程可见的、原子操作的变量，

- 多**线程**可以用程序内的公用变量mutex；多worker**进程**不是一个程序，显然不可以，所以要用到共享内存的信号量

![](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403205302353.png)

第二个参数pshared置为0，可以给一个进程里的多个线程共享信号量

![](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403205322126.png)

第二个参数不为0，只能给共享内存的多个进程之间共享信号量。

这些进程必须是一个父进程fork出来的，而且这些进程只能用sem_post和sem_wait函数来操作sem变量。

sem_wait()

![image-20220403205651490](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403205651490.png)

![image-20220403205719174](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403205719174.png)

如果大于0，初始化的信号量value--，立刻返回，否则**阻塞调用线程**。

sem_post()

![image-20220403205907953](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403205907953.png)

 ![image-20220403210034898](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403210034898.png)

可以唤醒别处阻塞的线程

###### 自旋锁和互斥锁的区别

> 当一个线程已经抢到了锁，
>
> 自旋锁会导致被阻塞的线程让cpu空转，直到前一个线程释放锁，才得到锁。
>
> 互斥锁会导致被阻塞的线程进入休眠，cpu线程切换，cpu执行其他的可执行线程。

###### 自旋锁和互斥锁的选择

> 切换线程要保存线程上下文。
>
> 当线程操作时间超过切换时间，使用互斥锁
>
> 否则用自旋锁。

> **锁的粒度：执行临界资源的时长**。不是代码长度和数据结构大小

#### accept锁是两种锁的混用

> 由于**条件变量的操作并非原子操作**，因此在进行相关变量状态转变的时候，多线程若操作条件变量会造成错误。因此**在条件变量之前需要加互斥锁进行保护**，结束后及时解锁。
>
> 说白了，条件变量的使用是自旋锁，对条件变量计数的操作是互斥锁

##### 先获取自旋锁

```c
void
ngx_shmtx_lock(ngx_shmtx_t *mtx)
{
    ngx_uint_t         i, n;

    ngx_log_debug0(NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0, "shmtx lock");

    for ( ;; ) {
        //用原子方式实现自旋锁（cpu空转，while死循环是用户态实现原子自旋锁的一种方式）
        if (*mtx->lock == 0 && ngx_atomic_cmp_set(mtx->lock, 0, ngx_pid)) {
            return;
        }//和尝试获取是一样的，如果能拿到就返回，退出函数

        if (ngx_ncpu > 1) {//worker数量和cpu核数量是一样的

            for (n = 1; n < mtx->spin; n <<= 1) {//在忙等待的过程中，该线程会一直占用CPU资源

                for (i = 0; i < n; i++) {
                    //通知cpu降低能耗，因为此时cpu只是空转尝试获得自旋锁，没有别的业务
                    ngx_cpu_pause();
                }
				//不断尝试获取锁
                if (*mtx->lock == 0
                    && ngx_atomic_cmp_set(mtx->lock, 0, ngx_pid))
                {
                    return;
                }
            }
        }

```

![image-20220403203542259](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403203542259.png)

> 执行自旋锁的时候，对应执行pause系统调用，通知cpu转换到低能耗状态。

##### cpu转不动了，再通过信号量获取

```c
//到这里说明空转cpu获取自旋锁失败了，此时已经空转了一段时间
#if (NGX_HAVE_POSIX_SEM)//如果支持信号量的话

        if (mtx->semaphore) {
            (void) ngx_atomic_fetch_add(mtx->wait, 1);

            if (*mtx->lock == 0 && ngx_atomic_cmp_set(mtx->lock, 0, ngx_pid)) {
                (void) ngx_atomic_fetch_add(mtx->wait, -1);
                return;
            }

            ngx_log_debug1(NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0,
                           "shmtx wait %uA", *mtx->wait);
            
		   //查看初始化处代码，发现sem初始值等于0，说明第一次调用这里就已经阻塞了
            //为什么？因为这里是worker竞争处理业务，只要一个worker获得锁，所以本质上，这里需要互斥锁
            
            //互斥性的锁有：自旋锁，初值为0的互斥锁mutex
            
            //这里用信号量实现的互斥锁：对初值为0的信号量执行p/sem_wait操作，就可以实现互斥
            
            //多线程可以用程序内的公用变量mutex，
            //多worker进程不是一个程序，显然不可以，所以要用到共享内存的信号量
            while (sem_wait(&mtx->sem) == -1) {
                //以下代码因为阻塞不会执行
                ngx_err_t  err;

                err = ngx_errno;

                if (err != NGX_EINTR) {
                    ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, err,
                                  "sem_wait() failed while waiting on shmtx");
                    break;
                }
            }

            ngx_log_debug0(NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0,
                           "shmtx awoke");

            continue;
        }

#endif
        ngx_sched_yield();
    }
}
```

### 举例：静态资源加载

![image-20220403212732664](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403212732664.png)

> 前提：worker进程的逻辑处理是单进程的/线性的。
>
> 虽然worker进程最多能处理51200条，但不是同时处理。
>
> 静态资源加载是IO操作，是要从磁盘读取数据，会阻塞当前线程。
>
> 因此不能在主线程执行。

#### 处理方式

aio（异步io处理） + 线程池

![](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403213620132.png)

> 主线程：负责网络传输和业务操作（http协议解析，http路由，过滤，nginx反向代理）
>
> - HTTP路由是指**根据请求的URL路径**来匹配路由规则，将请求转发到**对应的处理函数或控制器**的过程。在HTTP路由中，常用的路由方式有两种：基于正则表达式的路由（定制化）和基于配置文件的路由（与代码部分分离，便于维护）。
>
>   在路由规则中，常用的参数有路由名称（规则）、请求方法（访问方式）、URL路径、处理函数或控制器（终点）等。其中，URL路径通常包括静态URL和动态URL。静态URL是指URL路径中不包含变量的路径，如"/home"、"/about"等。动态URL是指URL路径中包含变量的路径，如"/user/:id"、"/post/:slug"等。
>
>   路由的实现方式因语言和框架而异。在PHP中，常用的路由框架有Laravel、Symfony、Yii等；在Python中，常用的路由框架有Django、Flask、Tornado等；在Node.js中，常用的路由框架有Express、Koa、Hapi等。
>
> - 参数过滤：对请求参数进行过滤和校验，以**防止恶意攻击和注入攻击**。常见的参数过滤方式包括数据类型检查、长度限制、特殊字符过滤等。
>
>   文件上传过滤：对上传的文件进行过滤和检查，以确保文件的安全性和完整性。常见的文件上传过滤方式包括文件类型检查、文件大小限制、病毒扫描等。
>
>   XSS过滤：对请求中的**特殊字符和脚本**进行过滤和转义，以防止跨站脚本攻击（XSS）。常见的XSS过滤方式包括HTML转义、JavaScript转义等。
>
>   - 反射型XSS攻击是指攻击者将恶意脚本注入到**URL参数**中，当**用户访问带有恶意参数的URL**时，恶意脚本被执行。
>
>     存储型XSS攻击是指攻击者将恶意脚本上传到**Web服务器**上，当**其他用户访问**带有恶意脚本的页面时，恶意脚本被执行。
>
>     DOM型XSS攻击是指攻击者利用Web应用程序中的DOM操作，将恶意脚本注入到**Web页面**中，当用户浏览带有恶意脚本的页面时，恶意脚本被执行。
>
>   CSRF过滤：对请求中的来源进行验证和校验，以防止跨站请求伪造（CSRF）。常见的CSRF过滤方式包括添加Token、Referer验证等。**原理**：利用用户已登录的身份，在用户不知情的情况下，向Web应用程序发送恶意请求。例如，攻击者可以在一个图片链接中嵌入一个恶意的表单，当用户点击这个链接时，恶意表单被提交
>
>   SQL注入过滤：对请求中的SQL语句进行过滤和检查，以防止SQL注入攻击。常见的SQL注入过滤方式包括使用参数化查询（SQL语句的参数使用占位符代替，占位符的值由应用程序提供）、预编译语句（在参数化查询的基础上，在本地把SQL语句用二进制编译存储，下一次调用的时候，直接传编译好的二进制，而不是再次解析SQL语句）等。
>
> - 反向代理是一种网络技术，它可以将客户端请求转发到后端服务器上，并将后端服务器的响应返回给客户端。与正向代理不同的是，反向代理是隐藏在服务器后面的代理服务器，客户端并不知道请求的实际处理者是哪个服务器。
>
>   反向代理的作用是可以提高服务器的性能和可靠性，同时也可以提供负载均衡和高可用性功能。当客户端请求到达反向代理服务器时，反向代理服务器会根据设定的规则将请求转发到后端服务器中的一个或多个进行处理。这样可以降低单台服务器的负载压力，提高服务器的响应速度和稳定性。
>
>   反向代理的应用非常广泛，它可以用于Web服务器、数据库服务器、邮件服务器等各种服务器的负载均衡和高可用性方案中。常见的反向代理软件有Nginx、Apache、HAProxy等，它们都提供了丰富的配置选项和高级功能，可以满足不同场景下的需求。
>
>   ```json
>   server {
>       listen 80;
>       server_name example.com;
>           
>       location / {
>           proxy_pass http://backend_server:8080;
>           proxy_set_header Host $host;
>           proxy_set_header X-Real-IP $remote_addr;
>       }
>   }
>   ```
>
>   在这个配置中，Nginx会监听80端口，并将所有的客户端请求转发到名为"backend_server"的服务器的8080端口。同时，Nginx还会将客户端的Host和X-Real-IP头信息传递给后端服务器。
>
> 主线程不可以做阻塞的io操作，因为主线程要同时处理多条连接。

> 主线程：把IO操作push到任务消息队列，线程池worker不断取出队列的任务，这样阻塞的就是线程池的线程
>
> **push，pull体现了异步io思想**
>
> 线程池完成任务后，任务加入完成消息队列，消息队列根据任务中的参数，发给指定客户的连接ClientChannel，返回给用户Socket

#### 细节

![image-20220403213829524](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403213829524.png)

> 多个线程池线程同时访问任务队列（一个写，多个读）

> 线程池线程进行的是文件加载任务，涉及系统调用和磁盘读取，属于重度IO操作。时间大于调度时间，所以**不用自旋锁用互斥锁**。

*队列中大于线程池大小的线程的等待时间，决定了用互斥锁。*

![image-20220403214350055](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403214350055.png)

> 线程池的线程**已经加载完数据**，只需要把数据push到队列，主线程只需要去队列取即可。
>
> 只涉及队列操作，时间非常短，使用自旋锁。

![image-20220403214529951](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403214529951.png)

#### 业务变化

线程调度，实现现线程池休眠与唤醒

不是任何时候都有静态资源要加载，不加载静态资源的时候，要想办法让线程池休眠。

但是我们不知道左边任务队列什么时候有很多任务，这就涉及到线程调度。

#### 线程调度的锁

信号量（value初值0+wait操作）+ 条件变量

> 目的：在有任务的时候，线程池唤醒，否则线程池都休眠
>
> - 信号量休眠条件：value=0，表示没任务，此时谁调用sem_wait，谁休眠
> - 条件变量

##### 休眠/加上wait锁

![image-20220403215857110](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403215857110.png)

> t：任务队列任务集合，无任务时休眠线程池
>
> 方法1.加互斥锁，加锁成功后，休眠线程计数++
>
> 方法2.调用条件等待
>
> - 1）释放互斥锁，换成wait条件变量锁，让线程进入休眠（此时等待的是**其他进程**来唤醒我）
>
> - 2）当收到signal唤醒时，释放条件变量锁，开始尝试获得互斥锁	（此时等待的是**CPU**来唤醒我）
>
> 当线程被唤醒，才从pthread_cond_wait 下面继续执行，此时休眠线程计数--
>
> 方法3.已经不需要让它休眠了，释放互斥锁

![image-20220403220752303](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403220752303.png)

> 这两个lock和unlock不是对应的。
>
> - 第一个：lock是互斥锁，是访问条件变量用的，对应获得条件变量访问权后，加wait锁，释放掉了。
>
> - 第二个：unlock是在释放wait锁的时候，又把互斥锁加回去了，确保下次访问条件变量仍然是互斥的。

二锁区别：

> - 信号量依赖于value初始值，**依赖于临界资源个数**。
>
> - 条件变量很宽松，会**根据任务数量自己调节**ctx->sleep的数量，**自行唤醒**休眠需要的线程数量。

![image-20220403221207673](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403221207673.png)

##### 唤醒wait锁

唤醒一个线程

![image-20220403220427176](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403220427176.png)

##### 虚假唤醒

signal应该只唤醒一个，有的cpu会唤醒多个。

## 拓展

![image-20220403221456698](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403221456698.png)

actor：用户抽象的，轻量级进程（进程的隔离性）进程间通过消息队列通信。



线程池如何调度上万个actor的消息队列？（也是通过条件变量）

1.通过全局消息队列，只存放有任务的消息队列，线程池轮询全局消息队列。

执行一次之后，还有消息放队尾，没有移出。

在actor自己的消息队列和全局消息队列都加自旋锁。

 # 拓展

无锁队列



分布式锁：

1.公平锁：对应互斥锁

2.非公平锁：对应自旋锁



互斥锁内部原理

自旋锁对操作系统有什么限制。



任务队列，完成队列和全局队列与对应锁的关系和下面两种是一致的。**本质上都是生产消费模型。**

分布式延时队列：

分布式消息队列：下图左侧就是分布式消息队列，主线程是生产者，线程池是消费者。

**实现异步解耦问题**，不想阻塞主线程，就异步推给任务消息队列。

业务逻辑和文件加载IO解耦。

![image-20220403214529951](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403214529951.png)

数据库锁：索引（B+树，对不同字段加锁），事务，业务要解决的问题。

![image-20220403223237179](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403223237179.png)

![image-20220403223213449](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403223213449.png)

![image-20220403223304109](C:\Users\8208191402\AppData\Roaming\Typora\typora-user-images\image-20220403223304109.png)

# 乐观锁-悲观锁

> - 乐观锁是一种并发控制机制，用于防止多个线程同时修改同一数据时发生冲突。乐观锁的基本思想是：在每次数据更新操作前，先**读取数据的版本号**，然后将要修改的数据版本号加1，最后将**新的版本号和修改后的数据一起提交到数据库**中。如果在提交时发现数据的版本号已经被其他线程修改过了，则说明数据已经被其他线程修改过了，此时就需要回滚操作并重新尝试更新。
> - 乐观锁通常采用版本号或时间戳等方式来实现。在使用版本号时，**每个数据记录都有一个版本号**，每次更新时都会将版本号加1，当多个线程同时更新同一条记录时，只有一个线程可以成功更新，其他线程需要重新尝试更新。在使用时间戳时，每个数据记录都有一个时间戳，每次更新时都会将时间戳更新为当前时间，当多个线程同时更新同一条记录时，只有最后更新的线程可以成功更新，其他线程需要重新尝试更新。
> - 乐观锁的优点是实现简单，不会造成死锁等问题，但是它也有一些缺点，例如在高并发的情况下，会有**大量的重试操作**，从而降低系统性能。因此，在选择乐观锁时需要综合考虑系统的并发情况和性能需求。

> - 悲观锁是一种并发控制机制，用于防止多个线程同时修改同一数据时发生冲突。悲观锁的基本思想是：在每次数据更新操作前，先锁定数据，然后执行更新操作，最后解锁数据。在锁定期间，其他线程无法修改数据，只能等待锁的释放。
> - **悲观锁通常采用数据库的行级锁或表级锁**来实现。在使用行级锁时，每个数据记录都有一个锁，当一个线程要修改某个数据记录时，会先请求该记录的锁，如果该记录已经被其他线程锁定，则该线程需要等待该记录的锁释放。在使用表级锁时，整个表都被锁定，当一个线程要修改某个数据记录时，需要先锁定整个表，然后执行更新操作，最后解锁整个表。
> - 悲观锁的优点是能够保证数据的一致性，但是它也有一些缺点，例如在高并发的情况下，会有**大量的锁等待操作**，从而降低系统性能。因此，在选择悲观锁时需要综合考虑系统的并发情况和性能需求。
